# -*- coding: utf-8 -*-
"""
Created on Sat May 30 22:31:10 2020

@author: Mouiad
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import os
import re
import getLane
import cv2
# Code to generate lane coordinates from probablity maps.
def save(original,path22):
    mask = np.zeros_like(original).astype(np.unicode)
    f = open(path22, "r")
    for line in f :
        x = []
        y = []
        points = line.split(" ")
        for i in range(0,(len(points)-1),2):
            x.append(points[i])
            y.append(points[i+1])

        for i  in range(0 , len(x)-1):
            #print(x[i] , y[i])
            cv2.line(original, (int(float(x[i])), int(y[i])),(int(float(x[i+1])), int(y[i+1])) , (0,255,0), 8)
    #print("--------------------------------------------------------------------------")
    
    return original
    #cv2.waitKey(0)
# Experiment name
exp = "vgg_SCNN_DULR_w9"
# Data root
data = "../data/CULane"
# Directory where prob imgs generated by CNN are saved.
probRoot = "../experiments/predicts/" + exp
# Directory to save fitted lanes.
output = "../prob2lines/output/" + exp
#print(output)
testList = data + "/list/test.txt"  # TODO edited the text file
show = False  # set to true to visualize
#fil=open(r"C:\Users\Mouiad\Desktop\Codes-for-Lane-Detection\SCNN-Tensorflow\lane-detection-model\data\CULane\video_out.txt",'w')
with open(testList) as f:
    image_list = f.readlines()

count=0
with open(testList,'r') as f:
    for line in f:
        count+=1    
#print("Total number of line is: "+str(count))
image_list = [x.strip() for x in image_list]
imname=image_list[0]
img = mpimg.imread(data + imname)
#print(img)
im=imname[-20:-14]
global path11
path11=r"C:\Users\Mouiad\Desktop\Codes-for-Lane-Detection\SCNN-Tensorflow\lane-detection-model\Visual_output\Dl\video\\"+im
try:
    os.makedirs(path11)
    #print("Directory ",path," Created")
except FileExistsError:
    pass
    #print("Directory ",path," already exists")
num = len(image_list)
pts = 18
for i in range(num):
    if np.mod(i + 1, 100) == 0:
        print(('Processing the %d th image...\\n'), i)
    imname = image_list[i]
    existPath = probRoot + imname[:-3] + "exist.txt"
    
    with open(existPath) as f:
        
        exist = f.readlines()
    exist = [y for x in exist for y in x if y == '1' or y == '0']
    # TODO better to show with opencv
    coordinates = np.zeros((4, pts))
    for j in range(4):
        if exist[j] == '1':
            scorePath = probRoot + imname[:-4] + "_" + str(j + 1) + "_avg.png"
            scoreMap = mpimg.imread(scorePath) * 255.0
            coordinate = getLane.getLane(scoreMap)
            coordinates[j, :] = coordinate
        if show:
            img = mpimg.imread(data + imname)
            image_name=imname[-8:]
            #im=imname[-20:-14]
           
            #print(im)
            #print(image_name)
            probMaps = np.uint8(np.zeros((288, 800, 3)))  # TODO this needs to change for the right size
            
            for k in range(4):
                color = ['g', 'b', 'r', 'y']
                if exist[k] == '1':
                    for m in range(pts):  # The devil is in the details m and k and -1
                        if coordinates[k, m] > 0:  # plotting!
                            plt.plot(np.uint16(np.round(coordinates[k, m] * 1640.0 / 800.0)) - 1, np.uint16(np.round(590 - m * 20)) - 1, "." + color[k], "markersize", 30)
                probPath = probRoot + imname[:-4] + "_" + str(k + 1) + "_avg.png"
                name=probRoot + imname[:-4] + "_" + str(k + 1)
                probMap = mpimg.imread(probPath) * 255 # The mod
                probMaps[:, :, np.mod(k + 1, 3)] = probMaps[:, :, np.mod(k + 1, 3)] + probMap
            #plt.figure(figsize = (10,5))
            if j==3 and count==1:
                
                plt.imshow(img)
                plt.savefig(r"C:\Users\Mouiad\Desktop\Codes-for-Lane-Detection\SCNN-Tensorflow\lane-detection-model\Visual_output\Dl\image\\"+image_name,bbox_inches='tight',pad_inches=-0.4)
            elif j==3 and count>1:
                plt.imshow(img)
                plt.savefig(path11+"/"+image_name,bbox_inches='tight',pad_inches=-0.4)
                #fil.write(r"C:\Users\Mouiad\Desktop\Codes-for-Lane-Detection\SCNN-Tensorflow\lane-detection-model\Visual_output\Dl\video\\"+image_name)
                #fil.write("\n")
                plt.close()
            
        else:
            img = mpimg.imread(data + imname)
            image_name=imname[-8:]
            save_name = output + imname[:- 3] + "lines.txt"
            position = [m.start() for m in re.finditer('/', save_name)]
            prefix = ''
            if position:
                prefix = save_name[:position[-1]]
            if not os.path.exists(prefix) and prefix != ' ':
                os.makedirs(prefix)
            fp = open(save_name, "w")
            for k in range(4):
                if exist[k] == '1' and np.sum(coordinates[k, :] > 0) > 1:
                    for m in range(pts):
                        if coordinates[k, m] > 0:
                            fp.write(str(np.uint16(np.round(coordinates[k, m] * 1640.0 / 800.0)) - 1) + ' ' + str(np.uint16(np.round(590 - m * 20)) - 1) + ' ')
                            #print(np.uint16(np.round(coordinates[k, m] * 1640.0 / 800.0)) - 1, np.uint16(np.round(590 - m * 20)) - 1)
                    fp.write('\n')
            fp.close()
            if j==3 and count==1:
              ime=save(img,save_name)
              plt.imsave(r"C:\Users\Mouiad\Desktop\Codes-for-Lane-Detection\SCNN-Tensorflow\lane-detection-model\Visual_output\Dl\image\\"+image_name,ime)
              cv2.imshow("image" , ime)
            elif j==3 and count>1:
                ime=save(img,save_name)
                #cv2.imwrite(path11+"/"+image_name,ime)
                plt.imsave(path11+"/"+image_name,ime)
def pat():
    return path11